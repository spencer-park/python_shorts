## 팩토리얼 예제로만 배우는 재귀함수는 그만
재귀함수의 대표 예제인 팩토리얼. 재귀함수의 특징을 파악하기 좋지만, 막상 다른 상황에 활용하기엔 막막한 예제이다.
이에 적절한 다른 예제인 계단 예제를 가져왔다.

## 한 번에 계단을 1~3개 오르를 수 있을 때. 한 번에 오를 수 있는 구간
1~3 까지 올라갈 수 있을 때 각 계단을 오를 수 있는 경우의 수를 확인해보자.

**1~3계단 오르는 경우의 수**
|계단|경우의 수|케이스|
|-|:-:|-|
|1개|1|(1)|
|2개|2|(1,1) (2)|
|3개|4|(1,2) (1,1,1) (2,1) (3)|

## 계단 4개일 때. 더 이상 한 번에 올라갈 수 없다.
이제 슬슬 단순하게 세기에는 어려운 계단 4개째다.
그런데 여기에 이전까지 가능했던 것이 사라진다.
"한 번에 목표 계단까지 오르는 것"
왜냐하면 1~3까지만 오를 수 있기 때문에 
무조건 4번째 계단 직전에는 1, 2, 3 중 하나를 밟고 있어야한다.

4번째 계단에 오르는 방법은 직전 상태들의 합!
'계단 1에 오르는 방법수 + 계단 2에 오르는 방법 수 + 계딴 3에 오르는 방법 수'가 된다.
즉, 1 + 2 + 4 = 7 이다.

간혹 이걸 계산할 때 "계단 2상태에서 2→3→4로 갈 수 있지 않나?"라고 헷갈릴 수 있는데,
’직전 단계가 2’라는 것은 **2→4가 이미 확정된 상황**이며
2→3→4는 ‘직전 단계 3’ 상황에 해당한다.

아직도 헷갈릴 수 있다. 부끄러운게 아니니 7개인지 직접 세보도록 하자.
**1~3계단 오르는 경우의 수**
|목표 계단|경우의 수|케이스|
|-|:-:|-|
|1개|1|(1)|
|2개|2|(1,1) (2)|
|3개|4|(1,2) (1,1,1) (2,1) (3)|

**4계단 오르는 경우의 수**
|직전 상태|확정된 다음 액션|경우의 수|케이스|
|-|:-:|:-:|-|
|직전 계단 0일 경우|불가|-|-|
|직전 계단 1일 경우|1→4|1|(**1**,3)|
|직전 계단 2일 경우|2→4|2|(**1,1**,2) (**2**,2)|
|직전 계단 3일 경우|3→4|4|(**1,2**,1) (**1,1,1**,1) (**2,1**,1) (**3**,1)|
위의 표 '케이스'에서 두껍게 칠해진 부분만 보면, 이전 1~3단계를 정리한 표와 동일하다. 그리고 '케이스'에서 볼드체가 아닌 부분은 '확정된 다음 액션'과 동일하다.

## 재귀함수의 Key Point는 '결과 직전 상태' 즉, 역추적.
’한 번에 오르는 경우’가 있을 때와 없을 때의 시점.
즉 **이전 단계와 상관없는 경우가 더 이상 발생하지 않는 상황까지의 규칙 정의**를 마쳤다면 재귀함수를 위한 준비는 완성된 것이다.

1. 계단 1, 2, 3 까지는 직접 세고, 
1. 계단 4개는 한 번에 오른다는 새로운 상태는 없으니
1. ‘4에 오르기 직전 상태’를 역으로 거슬러 올라가보자.
1. '4에 오르기 직전 상태'는 '계단 1', '계단 2', '계단 3'
1. 직전 상태가 될 수 있는 상황(계단 1,2,3)들의 경우의 수를 합하면 현재 상태(계단 4)의 경우의 수가 된다.

## 이제 코드로
참고 : sol1.py
위의 상황을 코드로 적기위하여 표현을 정리해보자.
```
계단 4개를 오르는 방법의 수
= ’이전 단계인 3까지 오르는 경우의 수’
+= ‘이전 단계인 2까지 오르는 경우의 수’
+= ‘이전 단계인 1까지 오르는 경우의 수’

계단 3개를 오르는 방법의 수 =
’이전 단계인 2까지 오르는 경우의 수’
= ‘이전 단계인 1까지 오르는 경우의 수’
+= ‘한 번에 오르는 경우’

계단 2개를 오르는 방법의 수
= ‘이전 단계인 1까지 오르는 경우의 수’
+= ‘한 번에 오르는 경우’

계단 1개를 오르는 방법의 수
= ‘한 번에 오르는 경우’
```

```python
def step_case(stair: int):
    if stair == 1:
        """계단 1개를 오르는 방법의 수
        = ‘한 번에 오르는 경우’
        """
        return 1
    elif stair == 2:
        """계단 2개를 오르는 방법의 수
        = ‘이전 단계인 1까지 오르는 경우의 수’
        += ‘한 번에 오르는 경우’
        """
        return 2
    elif stair == 3:
        """계단 3개를 오르는 방법의 수
        = ’이전 단계인 2까지 오르는 경우의 수’
        += ‘이전 단계인 1까지 오르는 경우의 수’
        += ‘한 번에 오르는 경우’
        """
        return 4
    else:
        """계단 4개를 오르는 방법의 수
        = ’이전 단계인 3까지 오르는 경우의 수’
        += ‘이전 단계인 2까지 오르는 경우의 수’
        += ‘이전 단계인 1까지 오르는 경우의 수’
        """
        return (
            step_case(stair - 3)
            + step_case(stair - 2)
            + step_case(stair - 1)
        )

print(f'{step_case(1) = }')
print(f'{step_case(2) = }')
print(f'{step_case(3) = }')
print(f'{step_case(4) = }')
print(f'{step_case(5) = }')
print(f'{step_case(6) = }')
print(f'{step_case(100) = }')
```

## (선택사항) 계단 1~3의 코드 축소
참고 : sol2.py
1~3까지 보면 여기서도 규칙이 보인다.
그래서 아래 코드처럼 변경할 수도 있겠으나, 오히려 리스트컴프리헨션을 처리하기위한 시간이 걸리니, 직접 값을 입력하는 위의 방식이 성능은 더 좋다. 따라서 권장하지 않는다.
```python
def step_case(stair: int):
    if stair < 1:
        return 0
    elif 1 <= stair < 4:
        """계단 3개를 오르는 방법의 수 =
        = ’이전 단계인 2까지 오르는 경우의 수’
        += ‘이전 단계인 1까지 오르는 경우의 수’
        += ‘한 번에 오르는 경우’
        """
        return 1 + sum([step_case(n) for n in range(1, stair)])
    else:
        """계단 4개를 오르는 방법의 수
        = ’이전 단계인 3까지 오르는 경우의 수’
        += ‘이전 단계인 2까지 오르는 경우의 수’
        += ‘이전 단계인 1까지 오르는 경우의 수’
        """
        return (
            step_case(stair - 3)
            + step_case(stair - 2)
            + step_case(stair - 1)
        )

print(f'{step_case(1) = }')
print(f'{step_case(2) = }')
print(f'{step_case(3) = }')
print(f'{step_case(4) = }')
print(f'{step_case(5) = }')
print(f'{step_case(6) = }')
print(f'{step_case(100) = }')
```

## 이제 5, 6, 7, 8도 생각해보자.
코드는 완성되었다. 그런데 4까지밖에 고려안했는데 완성된건가? 싶을 수 있는데 놀랍게도 '완성'했다.

5번째 계단일 때 직전 상황을 살펴볼건데,
이 때 2개의 테이블을 참고해서 보자.

**5계단의 직전 상태표(총 13개)**
|직전 상태|확정된 다음 액션|방법 수|이전 상황 유무|
|-|:-:|:-:|:-:|
|직전 계단 0인 상태|불가|X|X|
|직전 계단 1인 상태|불가|X|X|
|직전 계단 2인 상태|2→5|2|X|
|직전 계단 3인 상태|3→5|4|X|
|직전 계단 4인 상태|3→5|7|O|

**4계단의 직전 상태표(총 7개)**
|직전 상태|확정된 다음 액션|방법 수|
|-|:-:|:-:|
|직전 계단 0인 상태|불가|X|
|직전 계단 1인 상태|1→4|1|
|직전 계단 2인 상태|2→4|2|
|직전 계단 3인 상태|3→4|4|

즉, 5단계 경우는 '직전 상태 2~4'만 계산하면 되며,
직전 계단 4일 경우는 이미 1번의 복잡한 경우의 수 계산식이 반영된 상태이다.

이런 식으로 6계단, 7계단의 직전 상태표을 그려보면
**6계단의 직전 상태표(총 24개)**
|직전 상태|확정된 다음 액션|방법 수|이전 상황 유무}
|-|:-:|:-:|:-:|
|직전 계단 0인 상태|불가|X|X|
|직전 계단 1인 상태|불가|X|X|
|직전 계단 2일 경우|불가|X|X|
|직전 계단 3일 경우|3→6|4|X|
|직전 계단 4일 경우|4→6|7|O|
|직전 계단 5일 경우|5→6|13|O|

**7계단의 직전 상태표(총 44개)**
|직전 상태|확정된 다음 액션|방법 수|이전 상황 유무|
|-|:-:|:-:|:-:|
|직전 계단 0인 상태|불가|X|X|
|직전 계단 1인 상태|불가|X|X|
|직전 계단 2일 경우|불가|X|X|
|직전 계단 3일 경우|불가|X|X|
|직전 계단 4일 경우|4→7|7|O|
|직전 계단 5일 경우|5→7|13|O|
|직전 계단 6일 경우|5→7|24|O|

## n계단 직전 상태표를 만들기위해 이전 단계를 탐색
위와 같은 상황이 반복&누적되며 'n단계의 직전 상태표'가 만들어진다.

**n계단 직전 상태표**
|직전 상태|확정된 다음 액션|방법 수|이전 상황 유무|
|-|:-:|:-:|:-:|
|직전 계단 0인 상태|불가|X|X|
|직전 계단 ...인 상태|불가|X|X|
|직전 계단 n-4일 경우|불가|X|X|
|직전 계단 n-3일 경우|n-3 → n|7|O|
|직전 계단 n-2일 경우|n-2 → n|13|O|
|직전 계단 n-1일 경우|n-1 → n|24|O|

## 코드가 처리되는 과정
컴퓨터가 처리하는 방식도 우리가 지나왔던 사고방식과 동일하다.
지금껏 우리가 구현한 재귀방식은 다음과 같이 문제를 해결해나가며, 
이를 처리하는 주체가 우리에서 컴퓨터로 바뀌었다고 생각하면된다.
이미지는 우리 몸에 밧줄을 묶고 땅 깊숙히 파내려가고 있는 모습을 떠올리자.
1. (막연한 상황) N계단까지 오르는 방법 수는 몇 일까?
1. N계단 오르기 직전 상태와 경우의 수는 어떻게 될까? 
    1. 그 상태에 오르기 직전 상태와 경우의 수는 어떻게 될까?
        1. 그 상태에 오르기 직전 상태와 경우의 수는 어떻게 될까?
            1. 그 상태에 오르기 직전 상태와 경우의 수는 어떻게 될까?..
            - (반복...)
1. 계속 파고 내려가니 더 이상 내려가지 않는 구간이 있네?
    - 예제에선 '목표가 1~3번째 계단'인 상태
1. 그럼 더 이상 내려가지 않는 구간을 찾았으니 아까 돌아온 길로 차근히 돌아가자.
1. N계단 오르기 직전 상태와 경우의 수가 계산되었어!
1. (계산 완료) N계단까지 오르는 방법 수는 OO이야!


